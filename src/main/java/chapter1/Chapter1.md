# 들어가며 
"사소한 곳에서 발휘하는 정직은 사소하지 않다"  
이 책은 사소한듯 보이나 실제로는 사소하지 않은 내용을 다룬다. 
테스트와 코드만으로 설계를 주도한다는 1990년대 후반의 생각으로는 더이상 안된다.  
### 5S 철학  
1. 정리 : 적절한 명명법 등과 같은 방법을 사용해 무엇이 어디에 있는지 알아야 한다. 
2. 정돈 : 물건마다 모두 제자리가 있다. -> 코드는 누구나 예상하는 위치에 있어야 한다. 
3. 청소 : 과거 이력이나 미래 바람을 기억한 주석은 지운다.  
4. 청결 : 책에서 다룰 것이다. 
5. 생활화 : 관례를 따르고, 자기 작품을 자주 돌아보고, 기꺼이 변경하는 규율을 뜻한다.  
  
읽기 좋은 코드는 돌아가는 코드만큼이나 중요하다.  
소프트웨어 설계에서 재작업은 가치를 가져온다.  
  
### 장인 정신 
장인 정신을 익히는 과정은 두 단계로 나뉜다. 바로 이론과 실전이다.  
첫째, 장인에게 필요한 원칙, 패턴, 기법, 경험이라는 지식을 습득해야 한다. 
둘째, 열심히 일하고 연습해 지식을 몸과 마음으로 체득해야 한다.  
  
이론은 얼마든지 쉽게 배울 수 있다.  
깨끗한 코드를 만드는 "그럴듯한"원칙을 모두 적어준 후 알아서 하라고 버려둔다면, 어떤 학생이 나오겠는가?   
이 책은 원칙만 가르치고 끝나지 않는다.  
  
깨끗한 코드를 작성하는 방법은 **배우기 어렵다**.  
단순히 원칙과 패턴을 안다고 깨끗한 코드가 나오는 것이 아니다.  
  
이 책은 쉽게 읽고 넘기는 책이 아니라, **아주 열심히 독파해야 하는 책**이다.  
그냥 가볍게 읽고 넘긴다면, 좋은 소프트웨어을 작성하는 "기분 좋은 책"하나를 더 읽은 것에 지나지 않다. 
  
# 1장 깨끗한 코드  
### 코드가 존재하리라  
코드를 다루는 책이라니! 
코드를 자동으로 생성하는 시대가 다가오는데 왜 필요할까?  
그러나 이 모든 소리는 헛소리이고 가망이 전혀 없다.  
왜? 코드는 요구사항을 상세히 표현하는 수단이니까!  
어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하고 표현하고, 추상화 하는것은 불가능하다.  
기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업, 바로 이것이 프로그래밍이다. 이렇게 명시한 결과가 바로 코드다!  
  
앞으로 프로그래밍 언어에서 추상화 수준은 점점 높아질 것이다.  
어떤 언어를 사용하든 코드는 기계가 이해하고 실행할 정도로 엄밀하고 정확하고 상세하고 정형화되어야 한다.   
  
언젠가 코드가 사라지리라 생각하는 사람들은 언젠가 비정형적인 수학이 나오리라 기대하는 수학자와 비슷하다.  
그들은 우리가 시키는 대로가 아니라 원하는대로 돌아가는 기계가 나오리라 기대한다.  
요구사항을 모호하게 줘도 우리 의도를 정확히 꿰뚫어 프로그램을 완벽하게 실행하는 그런 기계 말이다.  
  
절대로 불가능한 기대다. 창의력과 직관을 보유한 우리 인간조차 고객의 막연한 감정만 가지고는 성공적인 시스템을 구현하지 못한다! 
  
  
### 나쁜 코드 
80년대 후반 킬러앱을 구현한 회사가 있었다. 제품은 커다란 이기를 끌었고, 수많은 전문가가 구매해 사용했다.  
그런데 출시 주기가 길어지고, 이전 세대의 버그가 남아있고, 프로그램이 죽는 횟수가 늘어났다.  
그 회사는 얼마 못가 망했다.  
  
이 회사는 출시에 맞춰 빠르게 코드를 작성하고, 기능이 추가될수록 코드가 엉망이 되고, 결국 감당이 불가능한 수준에 이르렀다.  
**회사가 망한 원인은 바로 나쁜 코드 탓이었다.** 
  
그렇다면 나쁜 코드를 작성한 이유가 무엇일까?  
-> 급하고 서둘러서 그랬을 것이다.  
추후에 고쳐야지 생각하지만, **나중은 절대 오지 않는다.**  
  
### 나쁜 코드로 치르는 대가  
나쁜 코드는 개발 속도를 크게 떨어뜨린다.  
프로젝트 초반에는 번개처럼 나아가다가 점차 느려지고, 얽힌것을 풀기 위해 더 얽힌 코드를 쓰고...  
결국 생산성은 0에 수렴한다.  
이를 해결하기 위해 추가인력을 투입하지만, 추가인력은 프로젝트에 대한 이해도가 떨어지고, 점차 망해간다.  
  
- **원대한 재설계의 꿈**   
코드가 너무 엉망이라 재설계를 추구한다.  
관리층도 허락해서 시작하지만, 
새 코드가 기존의 구현을 다 따라잡는데 얼마나 걸릴지 모른다.  
기존 시스템을 따라잡을쯤이면, 스타트 멤버들은 보통 없어진다.  
  
- **태도**  
일정에 쫓기더라도 대다수 관리자는 좋은 코드를 원한다.  
그들이 일정과 요구사항을 강력하게 밀어붙이는 이유는 그것이 그들의 책임이기 때문이다.  
좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다.  
  
의사를 예로 들어보자.  
환자가 수술 전 손을 씻지 말라고 당부한다. 시간이 너무 걸리기 때문.  
확실히 환자는 상사다.  
하지만 의사는 거부한다. 질병과 감염의 위험은 환자보다 의사가 더 잘 아니까  
환자 말 그대로 따르는 의사는 전문가답지 못하다.  
  
프로그래머도 마찬가지이다. 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.  
  
  
- **원초적 난제**   
나쁜 코드가 업부 속도를 늦춘다는 사실은 익히 알지만, 기한을 맞추려면 나쁜 코드를 양산할 수 밖에 없다.  
그들은 빨리 가려고 시간을 들이지 않는다.  
전문가들은 나쁜 코드가 결국에는 생산성을 늦출 것임을 알고 있다.  
그러므로 기한을 맞추는 유일한 방법은, 그러니깐 빨리가는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관이다. 
  
- **깨끗한 코드란?** 
아마 프로그래머 수만큼이나 정의도 다양할 것이다.  
> 비야네 스트롭스트룹 C++ 창시자  
> 논리가 간단해야 버스가 숨어들지 못한다.  
> 외존성을 최대한 줄여야 유지보수가 쉬워진다.  
> 오류는 명백한 전략에 의거해 철저히 처리한다.  
> 성능을 최적으로 유지해야 사람들이 원칙없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다.  
> 깨끗한 코드는 한가지를 제대로 한다.  
  
비야네는 우아한 코드를 강조한다.  
사전에 의하면 '보기에 즐거운 코드'다.  
깨끗한 코드는 보는 사람들에게 즐거움을 선사해야 한다는 뜻이다.  
  
코드를 깨진 창문에 비유해보자.  
창문에 멀쩡한 집은 사람들이 무슨 짓을 하지 않지만, 창문이 깨진 집을 지나가면, 사람들이 쓰레기를 버리고 점점 더렵혀진다.  
코드도 마찬가지이다.  
세세한 사항까지 꼼꼼하게 신경써야 한다.  
프로그래머들이 대충 넘어가는 부분이 오류 처리다.  
메모리 누수, 경쟁 상태, 일관성 없는 명명성이 또 다른 예다.  
한마디로 요약하면, 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드다.  
  
깨끗한 코드란 한가지를 잘한다고 단언한다.  
수많은 소프트웨어 설계 원칙이 이 간단한 교훈 하나로 귀결된다는 사실은 우연이 아니다.  
나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고, 목적이 흐려진다.  
깨끗한 코드는 한 가지에 '집중' 한다.   
  
> 그래디 부치 Object Oriented Analysis and Design with Application 저자  
> 깨끗한 코드는 단순하고 직접적이다.  
> 깨끗한 코드는 잘 쓴 문장처럼 읽힌다.  
> 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다.  
> 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다.  
  
그래디는 비야네와 흡사한 의견을 표명하지만 **가독성**을 강조한다.  
특히 깨끗한 코드가 잘 쓴 문장처럼 읽혀야 한다는 시각을 특히!  
  
코드는 추측이 아니라 사실에 기반해야 한다.  
반드시 필요한 내용을 담고, 코드를 읽는 사람에게 프로그래머가 단호하다는 인상을 줘야한다.   
  
**큰 데이브 토마브 - OTI 창립자이자 이클립스 전략의 대부**  
> 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.   
> 의존성은 최소이며, 각 의존성을 명확히 정의한다.  
  
가독성을 중시하지만 한가지 중요한 반전을 더한다.  
깨끗한 코드란 **다른**사람이 고치기 쉽다고 단언한다.  
  
테스트 주도 개발이라는 분야가 큰 영향을 미치며, 코드가 아무리 우아하고, 가독성이 높아도, 테스트 케이스가 없으면 깨끗하지 않은 것이다.  
  
  
**마이클 페더스 - Working Effectively with Legacy Code 저자** 
> 깨끗한 코드 모두를 아우르는 특징이 하나 있다.  
> 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다.  
  
한마디로 요약하면 '주의'다.  
이것이 이 책의 주제이다.   
**깨끗한 코드는 주의깊게 작성한 코드다. 누군가 시간을 들여 깔끔하고 단정하게 정리한 코드이다** 
  
**론 제프리스 - Extreme  Programming installed 저자**  
> 모든 테스트를 통과한다.  
> 중복이 없다.  
> 시스템 내 모든 설계 아이디어를 표현한다.  
> 클래스, 메서드, 함수 등을 최대한 줄인다.  
  
중복에 집중해보자.  
같은 작업을 여러차례 반복한다면, 코드가 아이디어를 제대로 표현하지 못한다는 증거다.  
  
객체가 여러 기능을 수행한다면 여러 객체로 나눈다.  
메서드가 여러 기능을 수행한다면, 메서드 추출 리팩터링 기법을 적용해,  
기능을 명확히 기술하는 메서드 하나와, 기능을 실제로 수행하는 메서드 여러개로 나눈다.  
  
중복과 표현력만 신경써도, 깨끗한 코드라는 목표에 성큼 다가선다.  
지저분한 코드를 손볼 때, 이 두가지만 고려해도 코드가 크게 나아진다.  
하지만 저자는 하나를 더 고려한다.  
  
**중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기**   
이 세가지가 깨끗한 코드를 만드는 비결이다.  
  
**워드 커닝햄 - 위키 창시자**  
> 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.  
> 코드가 그 문제를 풀기 위한 언어처럼 보인다면, 아름다운 코드라 불러도 되겠다.  
  
깨끗한 코드는 읽으면서 놀랄일이 없어야 한다고 워드는 말한다. 
  
프로그램을 단순하게 보이도록 만드는 열쇠는 언어가 아니다.  
언어를 단순하게 보이도록 만드는 열쇠는 프로그래머다.    
  
### 우리들 생각  
이 책에서는 설명하는 내용을 절대적인 진리처럼 이야기한다.  
일단은 수용하는 태도를 가지고 읽자.  
이 책은 **오브젝트 멘토 진영이 생각하는 깨끗한 코드**를 설명한다.  
  
이 책에서 나오는 기법들은 논쟁의 여지가 있다.  
어떤 기법은 격렬히 반대할 수도 있다.  
단순히 반대하기 보단, 이 책의 생각을 이해하도록 노력하자.  


### 우리는 저자다  
우리는 저자다. 저자에게는 독자가 있다.  
그리고 저자에게는 독자와 잘 소통할 **책임**도 있다.   
  
우리는 우리의 코드를 적는 동시에 우리의 코드를 읽는다.  
  
만약 우리으가 코드를 작성하는 것을 비디오로 본다면,  
코드를 작성하는 시간과 읽는 시간의 비율은 1:10 이 될것이다.  
새 코드를 자면서 우리는 끊임없이 기존 코드를 읽는다.  
  
비율이 이렇게 높으므로, 읽기 쉬운 코드가 매우 중요하다.  
비록 읽기 쉬운 코드를 짜기가 쉽지는 않더라도 말이다.  
하지만 기존 코드를 읽어야 새 코드를 짜므로, 읽기 쉽게 만들면 사실은 짜기도 쉬워진다.  
  
이 논리에서 빠져나갈 방법은 없다.  
주변 코드를 읽지 않으면 새 코드를 짜지 못한다.  
주변 코드가 읽기 쉬우면 새 코드를 짜기도 쉽다.  
주변 코드를 읽기가 어려우면 새 코드를 짜기도 어렵다.  
그러므로 급하다면, 서둘러 끝내려면, 쉽게 짜려면, 읽기 쉽게 만들면 된다.  
  
### 보이스카우트 법칙  
잘짠 코드가 전부는 아니다.  
시간이 지나도 언제나 깨끗하게 유지해야 한다.  
그러므로 우리는 적극적으로 코드의 퇴보를 막아야 한다.  
  
미국 보이스카우트가 따르는 간단한 규칙이 프로그래머에게도 유용하다.  
**캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라**  
  
체크인할 때보다 좀 더 깨끗한 코드를 체크아웃 한다면 코드는 절대 나빠지지 않는다.  
한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다.  
변수 이름을 개선하고, 조금 긴 함수를 분할하고, 약간의 중복을 제거하고, 복잡한 if문 하나를 정리하면 충분하다.  
  
### 프리퀄과 원칙  
PPP 책 찾아서 읽어보기  
이 책은 PPP의 프리퀄이다.  
Principle, Patterns, and Practice  
  
### 결론 
예술에 대한 책을 읽는다고 예술가가 되지 못한다.  
책은 단지 예술가가 사용하는 도구와 기법, 그리고 생각하는 방식을 소개할 뿐이다.  
이 책 역시 마찬가지이다.  
