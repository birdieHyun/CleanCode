# 들어가며 
"사소한 곳에서 발휘하는 정직은 사소하지 않다"  
이 책은 사소한듯 보이나 실제로는 사소하지 않은 내용을 다룬다. 
테스트와 코드만으로 설계를 주도한다는 1990년대 후반의 생각으로는 더이상 안된다.  
### 5S 철학  
1. 정리 : 적절한 명명법 등과 같은 방법을 사용해 무엇이 어디에 있는지 알아야 한다. 
2. 정돈 : 물건마다 모두 제자리가 있다. -> 코드는 누구나 예상하는 위치에 있어야 한다. 
3. 청소 : 과거 이력이나 미래 바람을 기억한 주석은 지운다.  
4. 청결 : 책에서 다룰 것이다. 
5. 생활화 : 관례를 따르고, 자기 작품을 자주 돌아보고, 기꺼이 변경하는 규율을 뜻한다.  
  
읽기 좋은 코드는 돌아가는 코드만큼이나 중요하다.  
소프트웨어 설계에서 재작업은 가치를 가져온다.  
  
### 장인 정신 
장인 정신을 익히는 과정은 두 단계로 나뉜다. 바로 이론과 실전이다.  
첫째, 장인에게 필요한 원칙, 패턴, 기법, 경험이라는 지식을 습득해야 한다. 
둘째, 열심히 일하고 연습해 지식을 몸과 마음으로 체득해야 한다.  
  
이론은 얼마든지 쉽게 배울 수 있다.  
깨끗한 코드를 만드는 "그럴듯한"원칙을 모두 적어준 후 알아서 하라고 버려둔다면, 어떤 학생이 나오겠는가?   
이 책은 원칙만 가르치고 끝나지 않는다.  
  
깨끗한 코드를 작성하는 방법은 **배우기 어렵다**.  
단순히 원칙과 패턴을 안다고 깨끗한 코드가 나오는 것이 아니다.  
  
이 책은 쉽게 읽고 넘기는 책이 아니라, **아주 열심히 독파해야 하는 책**이다.  
그냥 가볍게 읽고 넘긴다면, 좋은 소프트웨어을 작성하는 "기분 좋은 책"하나를 더 읽은 것에 지나지 않다. 
  
# 1장 깨끗한 코드  
### 코드가 존재하리라  
코드를 다루는 책이라니! 
코드를 자동으로 생성하는 시대가 다가오는데 왜 필요할까?  
그러나 이 모든 소리는 헛소리이고 가망이 전혀 없다.  
왜? 코드는 요구사항을 상세히 표현하는 수단이니까!  
어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하고 표현하고, 추상화 하는것은 불가능하다.  
기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업, 바로 이것이 프로그래밍이다. 이렇게 명시한 결과가 바로 코드다!  
  
앞으로 프로그래밍 언어에서 추상화 수준은 점점 높아질 것이다.  
어떤 언어를 사용하든 코드는 기계가 이해하고 실행할 정도로 엄밀하고 정확하고 상세하고 정형화되어야 한다.   
  
언젠가 코드가 사라지리라 생각하는 사람들은 언젠가 비정형적인 수학이 나오리라 기대하는 수학자와 비슷하다.  
그들은 우리가 시키는 대로가 아니라 원하는대로 돌아가는 기계가 나오리라 기대한다.  
요구사항을 모호하게 줘도 우리 의도를 정확히 꿰뚫어 프로그램을 완벽하게 실행하는 그런 기계 말이다.  
  
절대로 불가능한 기대다. 창의력과 직관을 보유한 우리 인간조차 고객의 막연한 감정만 가지고는 성공적인 시스템을 구현하지 못한다! 
  
  
### 나쁜 코드 
80년대 후반 킬러앱을 구현한 회사가 있었다. 제품은 커다란 이기를 끌었고, 수많은 전문가가 구매해 사용했다.  
그런데 출시 주기가 길어지고, 이전 세대의 버그가 남아있고, 프로그램이 죽는 횟수가 늘어났다.  
그 회사는 얼마 못가 망했다.  
  
이 회사는 출시에 맞춰 빠르게 코드를 작성하고, 기능이 추가될수록 코드가 엉망이 되고, 결국 감당이 불가능한 수준에 이르렀다.  
**회사가 망한 원인은 바로 나쁜 코드 탓이었다.** 
  
그렇다면 나쁜 코드를 작성한 이유가 무엇일까?  
-> 급하고 서둘러서 그랬을 것이다.  
추후에 고쳐야지 생각하지만, **나중은 절대 오지 않는다.**  
  
### 나쁜 코드로 치르는 대가  
나쁜 코드는 개발 속도를 크게 떨어뜨린다.  
프로젝트 초반에는 번개처럼 나아가다가 점차 느려지고, 얽힌것을 풀기 위해 더 얽힌 코드를 쓰고...  
결국 생산성은 0에 수렴한다.  
이를 해결하기 위해 추가인력을 투입하지만, 추가인력은 프로젝트에 대한 이해도가 떨어지고, 점차 망해간다.  
  
- **원대한 재설계의 꿈**   
코드가 너무 엉망이라 재설계를 추구한다.  
관리층도 허락해서 시작하지만, 
새 코드가 기존의 구현을 다 따라잡는데 얼마나 걸릴지 모른다.  
기존 시스템을 따라잡을쯤이면, 스타트 멤버들은 보통 없어진다.  
  
- **태도**  
일정에 쫓기더라도 대다수 관리자는 좋은 코드를 원한다.  
그들이 일정과 요구사항을 강력하게 밀어붙이는 이유는 그것이 그들의 책임이기 때문이다.  
좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다.  
  
의사를 예로 들어보자.  
환자가 수술 전 손을 씻지 말라고 당부한다. 시간이 너무 걸리기 때문.  
확실히 환자는 상사다.  
하지만 의사는 거부한다. 질병과 감염의 위험은 환자보다 의사가 더 잘 아니까  
환자 말 그대로 따르는 의사는 전문가답지 못하다.  
  
프로그래머도 마찬가지이다. 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.  
  
  
- **원초적 난제**   
나쁜 코드가 업부 속도를 늦춘다는 사실은 익히 알지만, 기한을 맞추려면 나쁜 코드를 양산할 수 밖에 없다.  
그들은 빨리 가려고 시간을 들이지 않는다.  
전문가들은 나쁜 코드가 결국에는 생산성을 늦출 것임을 알고 있다.  
그러므로 기한을 맞추는 유일한 방법은, 그러니깐 빨리가는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관이다. 
  
- **깨끗한 코드란?** 
아마 프로그래머 수만큼이나 정의도 다양할 것이다.  
> 비야네 스트롭스트룹 C++ 창시자  
> 논리가 간단해야 버스가 숨어들지 못한다.  
> 외존성을 최대한 줄여야 유지보수가 쉬워진다.  
> 오류는 명백한 전략에 의거해 철저히 처리한다.  
> 성능을 최적으로 유지해야 사람들이 원칙없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다.  
> 깨끗한 코드는 한가지를 제대로 한다.  
  
비야네는 우아한 코드를 강조한다.  
사전에 의하면 '보기에 즐거운 코드'다.  
깨끗한 코드는 보는 사람들에게 즐거움을 선사해야 한다는 뜻이다.  
  
코드를 깨진 창문에 비유해보자.  
창문에 멀쩡한 집은 사람들이 무슨 짓을 하지 않지만, 창문이 깨진 집을 지나가면, 사람들이 쓰레기를 버리고 점점 더렵혀진다.  
코드도 마찬가지이다.  
세세한 사항까지 꼼꼼하게 신경써야 한다.  
프로그래머들이 대충 넘어가는 부분이 오류 처리다.  
메모리 누수, 경쟁 상태, 일관성 없는 명명성이 또 다른 예다.  
한마디로 요약하면, 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드다.  
  
깨끗한 코드란 한가지를 잘한다고 단언한다.  
수많은 소프트웨어 설계 원칙이 이 간단한 교훈 하나로 귀결된다는 사실은 우연이 아니다.  
나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고, 목적이 흐려진다.  
깨끗한 코드는 한 가지에 '집중' 한다.   
  
> 그래디 부치 Object Oriented Analysis and Design with Application 저자  
> 깨끗한 코드는 단순하고 직접적이다.  
> 깨끗한 코드는 잘 쓴 문장처럼 읽힌다.  
> 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다.  
> 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다.  
  
그래디는 비야네와 흡사한 의견을 표명하지만 **가독성**을 강조한다.  
특히 깨끗한 코드가 잘 쓴 문장처럼 읽혀야 한다는 시각을 특히!  
  
코드는 추측이 아니라 사실에 기반해야 한다.  
반드시 필요한 내용을 담고, 코드를 읽는 사람에게 프로그래머가 단호하다는 인상을 줘야한다. 